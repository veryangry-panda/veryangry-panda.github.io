<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NYOJ-6 喷水装置（一）]]></title>
    <url>%2F2018%2F09%2F08%2FNYOJ-6%2F</url>
    <content type="text"><![CDATA[题目描述现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0&lt;Ri&lt;15)的圆被湿润，这有充足的喷水装置i（1&lt;i&lt;600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。 输入第一行m表示有m组测试数据每一组测试数据的第一行有一个整数数n，n表示共有n个喷水装置，随后的一行，有n个实数ri，ri表示该喷水装置能覆盖的圆的半径。 输出输出所用装置的个数 样例输入2 5 2 3.2 4 4.5 6 10 1 2 3 1 2 1.2 3 1.1 1 2 样例输出2 5 思路首先了解一下贪心法的基本知识 贪心法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 理解一下这道题题意，草坪的长和宽是定值，喷水装置的作用范围是一个圆形，圆形与矩形草坪相交。简单的画出示意图，由于题目说草坪一定能被填满，所以不考虑半径小于1m的情况，即我们只需把草坪的长填满，就填满了整个草坪。 用简单的勾股定理可以把半径转化为占有的长度，即d=sqrt(r*r-1)，到这里这个问题就变成了一个简单的贪心问题了。 我们对喷水装置的半径进行排序，从半径最大的开始选取，依次添加其他的喷水装置，知道把整个草坪填满。 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int m; cin&gt;&gt;m;//m组测试数据 for(int i=0;i&lt;m;i++) &#123; int n;//n个喷水装置 cin&gt;&gt;n; double a[n]; for(int j=0;j&lt;n;j++) &#123; double x; cin&gt;&gt;x; a[j]=sqrt(x*x-1);//将半径转化为作用范围 &#125; //先对喷水装置的数组排序 sort(a,a+n);//对作用范围进行排序 int index=0;//记录添加的喷水装置的数量 double sum=0;//记录当前充满的长度 for(int j=n-1;j&gt;=0;j--) &#123; sum=sum+a[j];//将喷水装置添加进来 index++; if(sum&gt;=10) break; &#125; cout&lt;&lt;index&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次写博客]]></title>
    <url>%2F2018%2F09%2F04%2Ffirst%20blog%2F</url>
    <content type="text"><![CDATA[在朋友的怂恿下，我越发觉得写博客是一件有意义的事情，并不期望有多少点击量，就是记录一下自己的生活和自己的学习经历。 我希望在这里记录一个真实的自己！]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>

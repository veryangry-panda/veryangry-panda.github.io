<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[NYOJ-12 喷水装置（二）]]></title>
    <url>%2F2018%2F09%2F08%2FNYOJ-12%2F</url>
    <content type="text"><![CDATA[题目描述有一块草坪，横向长w,纵向长为h,在它的橫向中心线上不同位置处装有n(n&lt;=10000)个点状的喷水装置，每个喷水装置i喷水的效果是让以它为中心半径为Ri的圆都被润湿。请在给出的喷水装置中选择尽量少的喷水装置，把整个草坪全部润湿。 输入第一行输入一个正整数N表示共有n次测试数据。每一组测试数据的第一行有三个整数n,w,h，n表示共有n个喷水装置，w表示草坪的横向长度，h表示草坪的纵向长度。随后的n行，都有两个整数xi和ri,xi表示第i个喷水装置的的横坐标（最左边为0），ri表示该喷水装置能覆盖的圆的半径。 输出每组测试数据输出一个正整数，表示共需要多少个喷水装置，每个输出单独占一行。 如果不存在一种能够把整个草坪湿润的方案，请输出0。 样例输入2 2 8 6 1 1 4 5 2 10 6 4 5 6 5 样例输出1 2 思路这道题经过类似前面“喷水装置（一）”的分析转换，依旧是一个贪心问题，不过他有所不同的是加入了喷水装置的坐标，这就让我们不能随意摆放装置的位置。 这道题转换过后是一个区间完全覆盖问题。 何为区间完全覆盖问题，下面举一个例子来说明： 问题描述：给定一个长度为m的区间，再给出n条线段的起点和终点（注意这里是闭区间），求最少使用多少条线段可以将整个区间完全覆盖样例：区间长度8，可选的覆盖线段[2,6],[1,4],[3,6],[3,7],[6,8],[2,4],[3,5]解题过程:1 将每一个区间按照左端点递增顺序排列，拍完序后为[1,4]，[2,4]，[2,6]，[3,5]，[3,6]，[3,7]，[6,8]2 设置一个变量表示已经覆盖到的区域。再剩下的线段中找出所有左端点小于等于当前已经覆盖到的区域的右端点的线段中，右端点最大的线段在加入，直到已经覆盖全部的区域3过程:假设第一步加入[1,4]，那么下一步能够选择的有[2,6]，[3,5]，[3,6]，[3,7]，由于7最大，所以下一步选择[3,7]，最后一步只能选择[6,8]，这个时候刚好达到了8退出，所选区间为34贪心证明:需要最少的线段进行覆盖，那么选取的线段必然要尽量长，而已经覆盖到的区域之前的地方已经无所谓了，（可以理解成所有的可以覆盖的左端点都是已经覆盖到的地方），那么真正能够使得线段更成的是右端点，左端点没有太大的意义，所以选择右端点来覆盖 回到这道题中，经过跟“喷水装置（一）”类似的转换，我们可以将喷水装置的作用范围由一个圆化为一个区间，接着就可以使用贪心的方法来解决这个问题了 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081 #include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;algorithm&gt;#include &lt;math.h&gt;using namespace std;struct sb&#123; double from,to;&#125;a[10005];bool cmp(sb t1,sb t2)&#123; if(t1.from&lt;t2.from) return true; if(t1.from==t2.from&amp;&amp;t1.to&gt;t2.to) return true; return false;&#125;int main()&#123; int t,n,i; double d,h,r,w,x; cin&gt;&gt;t; while(t--) &#123; int count=0,flag=0,sum=0; double begin=0,end=0; cin&gt;&gt;n&gt;&gt;w&gt;&gt;h; for(i=0;i&lt;n;i++) &#123; cin&gt;&gt;x&gt;&gt;r; d=sqrt(r*r-((h/2)*(h/2))); if(r&gt;=(h/2)) &#123; if(x-d&gt;w||x+d&lt;0) continue; a[count].from=x-d; a[count].to=x+d; count++; &#125; &#125; if(count==0) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; std::sort(a,a+count,cmp); if(a[0].from&gt;0) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; double max=0; int num; for(i=0;i&lt;count;i++) &#123; if(a[i].from&lt;=end) &#123; for(int num=i;num&lt;count;num++) &#123; if(a[num].to&gt;max&amp;&amp;a[num].to&gt;end&amp;&amp;a[num].from&lt;=end) &#123; max=a[num].to; i=num; &#125; &#125; end=max; sum++; &#125; if(end&gt;w) break; &#125; if(end&lt;w||begin==end) &#123; cout&lt;&lt;0&lt;&lt;endl; continue; &#125; cout&lt;&lt;sum&lt;&lt;endl; &#125; return 0;&#125; 出现的问题上面贴出的代码来自互联网，为什么不贴自己的代码呢，因为我的代码出现的超时，这里也附上一个刚学到的代码超时的解决思路（来自某大牛）。对时间复杂度贡献最大的一般是循环，超时一般都发生在这种地方，所以首先检查你的代码中循环最多次的地方，如果能够把循环的重数降低，或者加上if等条件判断语句，再或者用break在某些情况下跳出循环，有利于缓解超时问题。]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[NYOJ-6 喷水装置（一）]]></title>
    <url>%2F2018%2F09%2F08%2FNYOJ-6%2F</url>
    <content type="text"><![CDATA[题目描述现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0&lt;Ri&lt;15)的圆被湿润，这有充足的喷水装置i（1&lt;i&lt;600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。 输入第一行m表示有m组测试数据每一组测试数据的第一行有一个整数数n，n表示共有n个喷水装置，随后的一行，有n个实数ri，ri表示该喷水装置能覆盖的圆的半径。 输出输出所用装置的个数 样例输入2 5 2 3.2 4 4.5 6 10 1 2 3 1 2 1.2 3 1.1 1 2 样例输出2 5 思路首先了解一下贪心法的基本知识 贪心法是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 理解一下这道题题意，草坪的长和宽是定值，喷水装置的作用范围是一个圆形，圆形与矩形草坪相交。简单的画出示意图，由于题目说草坪一定能被填满，所以不考虑半径小于1m的情况，即我们只需把草坪的长填满，就填满了整个草坪。 用简单的勾股定理可以把半径转化为占有的长度，即d=sqrt(r*r-1)，到这里这个问题就变成了一个简单的贪心问题了。 我们对喷水装置的半径进行排序，从半径最大的开始选取，依次添加其他的喷水装置，知道把整个草坪填满。 代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;math.h&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int m; cin&gt;&gt;m;//m组测试数据 for(int i=0;i&lt;m;i++) &#123; int n;//n个喷水装置 cin&gt;&gt;n; double a[n]; for(int j=0;j&lt;n;j++) &#123; double x; cin&gt;&gt;x; a[j]=sqrt(x*x-1);//将半径转化为作用范围 &#125; //先对喷水装置的数组排序 sort(a,a+n);//对作用范围进行排序 int index=0;//记录添加的喷水装置的数量 double sum=0;//记录当前充满的长度 for(int j=n-1;j&gt;=0;j--) &#123; sum=sum+a[j];//将喷水装置添加进来 index++; if(sum&gt;=10) break; &#125; cout&lt;&lt;index&lt;&lt;endl; &#125;&#125;]]></content>
      <categories>
        <category>ACM</category>
      </categories>
      <tags>
        <tag>贪心算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一次写博客]]></title>
    <url>%2F2018%2F09%2F04%2Ffirst%20blog%2F</url>
    <content type="text"><![CDATA[在朋友的怂恿下，我越发觉得写博客是一件有意义的事情，并不期望有多少点击量，就是记录一下自己的生活和自己的学习经历。 我希望在这里记录一个真实的自己！]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
</search>
